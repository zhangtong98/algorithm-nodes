package com.zhang.leetCode.easy;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
     二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。
     每个 LED 代表一个 0 或 1，最低位在右侧。
     例如，上面的二进制手表读取 “3:25”。
     给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。
     案例:
     输入: n = 1
     返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
     注意事项:
     输出的顺序没有要求。
     小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。
     分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
 */
public class ReadBinaryWatch {

    public static void main(String[] args) {
        for (String  s : readBinaryWatchV2(2)) {
            System.out.println(s);
        }
    }

    public static List<String> readBinaryWatchV3(int num) {
        switch (num){
            case 0:
                return Arrays.asList(new String[]{"0:00"});
            case 1:
                return Arrays.asList(new String[]{"0:01", "0:02", "0:04", "0:08", "0:16", "0:32", "1:00", "2:00", "4:00", "8:00"});
            case 2:
                return Arrays.asList(new String[]{"0:03", "0:05", "0:06", "0:09", "0:10", "0:12", "0:17", "0:18", "0:20", "0:24", "0:33", "0:34", "0:36", "0:40", "0:48", "1:01", "1:02", "1:04", "1:08", "1:16", "1:32", "2:01", "2:02", "2:04", "2:08", "2:16", "2:32", "4:01", "4:02", "4:04", "4:08", "4:16", "4:32", "8:01", "8:02", "8:04", "8:08", "8:16", "8:32", "3:00", "5:00", "6:00", "9:00", "10:00"});
            case 3:
                return Arrays.asList(new String[]{"0:07", "0:11", "0:13", "0:14", "0:19", "0:21", "0:22", "0:25", "0:26", "0:28", "0:35", "0:37", "0:38", "0:41", "0:42", "0:44", "0:49", "0:50", "0:52", "0:56", "1:03", "1:05", "1:06", "1:09", "1:10", "1:12", "1:17", "1:18", "1:20", "1:24", "1:33", "1:34", "1:36", "1:40", "1:48", "2:03", "2:05", "2:06", "2:09", "2:10", "2:12", "2:17", "2:18", "2:20", "2:24", "2:33", "2:34", "2:36", "2:40", "2:48", "4:03", "4:05", "4:06", "4:09", "4:10", "4:12", "4:17", "4:18", "4:20", "4:24", "4:33", "4:34", "4:36", "4:40", "4:48", "8:03", "8:05", "8:06", "8:09", "8:10", "8:12", "8:17", "8:18", "8:20", "8:24", "8:33", "8:34", "8:36", "8:40", "8:48", "3:01", "3:02", "3:04", "3:08", "3:16", "3:32", "5:01", "5:02", "5:04", "5:08", "5:16", "5:32", "6:01", "6:02", "6:04", "6:08", "6:16", "6:32", "9:01", "9:02", "9:04", "9:08", "9:16", "9:32", "10:01", "10:02", "10:04", "10:08", "10:16", "10:32", "7:00", "11:00"});
            case 4:
                return Arrays.asList(new String[]{"0:15", "0:23", "0:27", "0:29", "0:30", "0:39", "0:43", "0:45", "0:46", "0:51", "0:53", "0:54", "0:57", "0:58", "1:07", "1:11", "1:13", "1:14", "1:19", "1:21", "1:22", "1:25", "1:26", "1:28", "1:35", "1:37", "1:38", "1:41", "1:42", "1:44", "1:49", "1:50", "1:52", "1:56", "2:07", "2:11", "2:13", "2:14", "2:19", "2:21", "2:22", "2:25", "2:26", "2:28", "2:35", "2:37", "2:38", "2:41", "2:42", "2:44", "2:49", "2:50", "2:52", "2:56", "4:07", "4:11", "4:13", "4:14", "4:19", "4:21", "4:22", "4:25", "4:26", "4:28", "4:35", "4:37", "4:38", "4:41", "4:42", "4:44", "4:49", "4:50", "4:52", "4:56", "8:07", "8:11", "8:13", "8:14", "8:19", "8:21", "8:22", "8:25", "8:26", "8:28", "8:35", "8:37", "8:38", "8:41", "8:42", "8:44", "8:49", "8:50", "8:52", "8:56", "3:03", "3:05", "3:06", "3:09", "3:10", "3:12", "3:17", "3:18", "3:20", "3:24", "3:33", "3:34", "3:36", "3:40", "3:48", "5:03", "5:05", "5:06", "5:09", "5:10", "5:12", "5:17", "5:18", "5:20", "5:24", "5:33", "5:34", "5:36", "5:40", "5:48", "6:03", "6:05", "6:06", "6:09", "6:10", "6:12", "6:17", "6:18", "6:20", "6:24", "6:33", "6:34", "6:36", "6:40", "6:48", "9:03", "9:05", "9:06", "9:09", "9:10", "9:12", "9:17", "9:18", "9:20", "9:24", "9:33", "9:34", "9:36", "9:40", "9:48", "10:03", "10:05", "10:06", "10:09", "10:10", "10:12", "10:17", "10:18", "10:20", "10:24", "10:33", "10:34", "10:36", "10:40", "10:48", "7:01", "7:02", "7:04", "7:08", "7:16", "7:32", "11:01", "11:02", "11:04", "11:08", "11:16", "11:32"});
            case 5:
                return Arrays.asList(new String[]{"0:00"});
            case 6:
                return Arrays.asList(new String[]{"0:00"});
            case 7:
                return Arrays.asList(new String[]{"0:00"});
            case 8:
                return Arrays.asList(new String[]{"0:00"});
        }
        return null;
    }


    public static List<String> readBinaryWatch(int num) {
        List<String> res = new ArrayList<>();
        for (int h = 0; h < 12; h++) {
            for (int m = 0; m < 60; m++) {
                //bitCount实现的功能是计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量。
                if (Integer.bitCount(h)+Integer.bitCount(m) == num){
                    res.add(String.format("%d:%02d",h,m));
                }
            }
        }
        return res;
    }

    public static List<String> readBinaryWatchV2(int num) {
        List<String> ans = new ArrayList<>();
        for (int i = 0; i <= num; i++) {
            if (i >= 4) break;
            if (num - i >= 6) continue;
            List<String> lefts = getLeft(i);
            List<String> rights = getRight(num - i);
            for (String left : lefts) {
                for (String right : rights) {
                    ans.add(left + ":" + right);
                }
            }
        }
        return ans;
    }

    private static List<String> getLeft(int v) {
        List<String> ans = new ArrayList<>();
        for (int i = 0; i < 12; i++) {
            if (getNum(i) == v) ans.add(i + "");
        }
        return ans;
    }

    private static List<String> getRight(int v) {
        List<String> ans = new ArrayList<>();
        for (int i = 0; i < 60; i++) {
            if (getNum(i) == v) {
                if (i < 10) ans.add("0" + i);
                else ans.add(i + "");
            }
        }
        return ans;
    }

    private static int getNum(int v) {
        int ans = 0;
        while (v > 0) {
            ans += v % 2;
            v /= 2;
        }
        return ans;
    }
}
